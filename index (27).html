<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Geometric Painter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            /* Prevent pull-to-refresh and overscroll on mobile */
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }
        #root {
            width: 100vw;
            height: 100vh;
            /* Prevent selection highlighting on touch */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        /* Scrollbar styling for control panel */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(107, 181, 199, 0.3);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(107, 181, 199, 0.5);
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            /* Make scrollbar thinner on mobile */
            ::-webkit-scrollbar {
                width: 4px;
            }
        }
        
        @media (max-width: 480px) {
            /* Very small screens - adjust panel width */
            .control-panel {
                min-width: 260px !important;
                max-width: calc(100vw - 40px) !important;
            }
        }
        
        /* Prevent iOS Safari from bouncing */
        html, body {
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        /* Pulse animation for fill notification */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.05);
            }
        }
    </style>
    <!-- Load Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600&family=Cormorant+Garamond:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div id="root"></div>
    
    <!-- Load React and Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- The App -->
    <script type="text/babel">

const { useRef, useEffect, useState } = React;

const GeometricPainter = () => {
  const canvasRef = useRef(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [selectedColor, setSelectedColor] = useState('#6bb5c7');
  const [brushSize, setBrushSize] = useState(40);
  const [brushMode, setBrushMode] = useState('segments');
  const [opacity, setOpacity] = useState(0.7);
  const [lineWeight, setLineWeight] = useState(1);
  const [shapeMode, setShapeMode] = useState(null);
  const [showUI, setShowUI] = useState(true);
  const [isHolding, setIsHolding] = useState(false);
  const [bleedEnabled, setBleedEnabled] = useState(false);
  const [blendMode, setBlendMode] = useState(false);
  const [fillMode, setFillMode] = useState(false);
  const [fillPattern, setFillPattern] = useState('solid');
  const [fillPatternDensity, setFillPatternDensity] = useState(50); // 0-100
  const [fillPatternRotation, setFillPatternRotation] = useState(0); // 0-360
  const [symmetryMode, setSymmetryMode] = useState('none');
  const [mirrorAngle, setMirrorAngle] = useState(90); // 90 = vertical mirror
  const [canUndo, setCanUndo] = useState(false);
  const [showInstructions, setShowInstructions] = useState(false);
  const [shapeFilled, setShapeFilled] = useState(false);
  const [currentPalette, setCurrentPalette] = useState('original');
  const [customPalettes, setCustomPalettes] = useState({});
  const [panelCollapsed, setPanelCollapsed] = useState(false);
  const [isMobile, setIsMobile] = useState(false);
  const [canvasZoom, setCanvasZoom] = useState(1);
  const [canvasPan, setCanvasPan] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [fillNotification, setFillNotification] = useState(false);
  const [canvasInitialized, setCanvasInitialized] = useState(false);
  
  const undoHistoryRef = useRef([]);
  const maxUndoSteps = 20;
  
  // Zoom while keeping view centered (works with top-left transform origin)
  const zoomCentered = (newZoom) => {
    const oldZoom = canvasZoom;
    
    // Find canvas point that's currently at viewport center
    const viewportCenterX = window.innerWidth / 2;
    const viewportCenterY = window.innerHeight / 2;
    
    // With top-left origin: screenPos = pan + canvasPos * zoom
    const canvasCenterX = (viewportCenterX - canvasPan.x) / oldZoom;
    const canvasCenterY = (viewportCenterY - canvasPan.y) / oldZoom;
    
    // Calculate new pan to keep that canvas point at viewport center
    const newPanX = viewportCenterX - canvasCenterX * newZoom;
    const newPanY = viewportCenterY - canvasCenterY * newZoom;
    
    setCanvasPan({ x: newPanX, y: newPanY });
    setCanvasZoom(newZoom);
  };
  
  // Transform screen coordinates to canvas coordinates accounting for zoom and pan
  const screenToCanvas = (clientX, clientY) => {
    const rect = canvasRef.current.getBoundingClientRect();
    
    // With CSS transform: translate(pan) scale(zoom) and transform-origin: top-left
    // A canvas point (cx, cy) appears at screen position: panX + cx*zoom
    // So to get canvas coords from screen coords: cx = (clientX - rect.left) / zoom
    const canvasX = (clientX - rect.left) / canvasZoom;
    const canvasY = (clientY - rect.top) / canvasZoom;
    
    return { x: canvasX, y: canvasY };
  };
  
  // Multiple color palettes
  const builtInPalettes = {
    original: {
      name: 'Mystic Desert',
      colors: [
        { name: 'Cyan Glow', color: '#6bb5c7' },
        { name: 'Deep Teal', color: '#1a3a3a' },
        { name: 'Azure', color: '#4a8a9e' },
        { name: 'Golden', color: '#e6a660' },
        { name: 'Coral', color: '#e87a6a' },
        { name: 'Amber', color: '#d4854d' },
        { name: 'Cream', color: '#f4e8d4' },
        { name: 'Turquoise', color: '#7acab5' },
        { name: 'Violet', color: '#8a5a8a' },
        { name: 'Rose', color: '#c45a4a' },
        { name: 'Sage', color: '#5a9a8a' },
        { name: 'Midnight', color: '#0d2d3d' },
        { name: 'Terracotta', color: '#b8754a' },
        { name: 'Dusty Pink', color: '#d8a8a8' },
        { name: 'Slate Blue', color: '#5a6a7a' },
        { name: 'Background', color: '#0a0a0a' }
      ]
    },
    painterly: {
      name: 'Painterly',
      colors: [
        { name: 'Vivid Ochre', color: '#F2A950' },
        { name: 'Burnt Sienna', color: '#D75842' },
        { name: 'Cadmium Red', color: '#D84545' },
        { name: 'Rose Red', color: '#E96B7F' },
        { name: 'Oxblood', color: '#8C4839' },
        { name: 'Deep Carmine', color: '#B83A4A' },
        { name: 'Muted Rose', color: '#6B3543' },
        { name: 'Wine Dregs', color: '#8A4A69' },
        { name: 'Ultramarine', color: '#1E3A72' },
        { name: 'Steel Blue', color: '#2B5E7D' },
        { name: 'Obsidian', color: '#1D1D1D' },
        { name: 'Graphite', color: '#604A79' },
        { name: 'Pale Sand', color: '#4A8271' },
        { name: 'Parchment', color: '#F4E7D6' },
        { name: 'Raw Sienna', color: '#F0C898' },
        { name: 'Mauve Shadow', color: '#D9A7A0' }
      ]
    },
    earth: {
      name: 'Earth Tones',
      colors: [
        { name: 'Terracotta', color: '#C9754D' },
        { name: 'Clay', color: '#A0654A' },
        { name: 'Rust', color: '#8B4513' },
        { name: 'Sand', color: '#E5C9A0' },
        { name: 'Moss', color: '#5A7A5A' },
        { name: 'Forest', color: '#3A5A3A' },
        { name: 'Stone', color: '#8A8A7A' },
        { name: 'Slate', color: '#556B6B' },
        { name: 'Bark', color: '#5A4A3A' },
        { name: 'Cream', color: '#F0E8D0' },
        { name: 'Charcoal', color: '#3A3A3A' },
        { name: 'Umber', color: '#6A4A2A' },
        { name: 'Ochre', color: '#CC7722' },
        { name: 'Olive', color: '#6B7A3A' },
        { name: 'Sienna', color: '#A0522D' },
        { name: 'Black', color: '#0a0a0a' }
      ]
    },
    ocean: {
      name: 'Ocean Depths',
      colors: [
        { name: 'Aqua', color: '#5FB8C7' },
        { name: 'Teal', color: '#2A7A8A' },
        { name: 'Navy', color: '#1A3A5A' },
        { name: 'Seafoam', color: '#8AD8C8' },
        { name: 'Coral', color: '#FF7F6A' },
        { name: 'Pearl', color: '#E8D8C8' },
        { name: 'Deep Blue', color: '#0A2A4A' },
        { name: 'Turquoise', color: '#4ACAA8' },
        { name: 'Sand', color: '#D8C8A8' },
        { name: 'Shell', color: '#F8E8D8' },
        { name: 'Kelp', color: '#3A5A3A' },
        { name: 'Storm', color: '#4A5A6A' },
        { name: 'Azure', color: '#3A7A9A' },
        { name: 'Cerulean', color: '#2E8BB5' },
        { name: 'Starfish', color: '#E8A878' },
        { name: 'Black', color: '#0a0a0a' }
      ]
    }
  };
  
  // Merge built-in and custom palettes
  const colorPalettes = { ...builtInPalettes, ...customPalettes };
  
  const colorPalette = colorPalettes[currentPalette]?.colors || builtInPalettes.original.colors;
  
  const lastPosRef = useRef({ x: 0, y: 0 });
  const bleedAnimationRef = useRef(null);
  const bleedStateRef = useRef({ x: 0, y: 0, radius: 0, maxRadius: 0 });
  
  // Mobile detection and orientation handling
  useEffect(() => {
    const checkMobile = () => {
      const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                            window.innerWidth <= 768;
      setIsMobile(isMobileDevice);
      
      // Auto-collapse panel on mobile
      if (isMobileDevice && window.innerWidth <= 768) {
        setPanelCollapsed(true);
      }
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    window.addEventListener('orientationchange', checkMobile);
    
    return () => {
      window.removeEventListener('resize', checkMobile);
      window.removeEventListener('orientationchange', checkMobile);
    };
  }, []);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // High-resolution canvas setup
    const dpr = window.devicePixelRatio || 1;
    
    // On mobile, make canvas square (2x width) for reasonable drawing space
    // On desktop, match viewport
    let canvasWidth, canvasHeight;
    if (isMobile) {
      const squareSize = window.innerWidth * 2;
      canvasWidth = squareSize;
      canvasHeight = squareSize;
    } else {
      canvasWidth = window.innerWidth;
      canvasHeight = window.innerHeight;
    }
    
    canvas.width = canvasWidth * dpr;
    canvas.height = canvasHeight * dpr;
    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    
    // Dark background inspired by the images
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    // Center canvas on mobile (only on first initialization)
    if (isMobile && !canvasInitialized) {
      // Pan to show center of canvas
      // Canvas is 2x viewport, so pan by -0.5x viewport to center
      const centerPanX = -(window.innerWidth / 2);
      const centerPanY = -(window.innerHeight / 2);
      setCanvasPan({ x: centerPanX, y: centerPanY });
      setCanvasInitialized(true);
    }
    
    // Save initial state to undo history
    saveToHistory();
    
    // Handle window resize and orientation changes
    const handleResize = () => {
      const dpr = window.devicePixelRatio || 1;
      
      // Match canvas size logic from above
      let canvasWidth, canvasHeight;
      if (isMobile) {
        const squareSize = window.innerWidth * 2;
        canvasWidth = squareSize;
        canvasHeight = squareSize;
      } else {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
      }
      
      // Save current canvas content
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(canvas, 0, 0);
      
      // Resize canvas
      canvas.width = canvasWidth * dpr;
      canvas.height = canvasHeight * dpr;
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      
      // Restore content
      ctx.drawImage(tempCanvas, 0, 0);
    };
    
    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);
    
    // Keyboard shortcut to toggle UI
    const handleKeyPress = (e) => {
      if (e.key === 'h' || e.key === 'H') {
        setShowUI(prev => !prev);
      }
      // Undo with Ctrl+Z or Cmd+Z
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    
    return () => {
      window.removeEventListener('keydown', handleKeyPress);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('orientationchange', handleResize);
    };
  }, [isMobile]);
  
  const saveToHistory = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const imageData = canvas.toDataURL();
    undoHistoryRef.current.push(imageData);
    
    // Limit history size
    if (undoHistoryRef.current.length > maxUndoSteps) {
      undoHistoryRef.current.shift();
    }
    
    setCanUndo(undoHistoryRef.current.length > 1);
  };
  
  const undo = () => {
    if (undoHistoryRef.current.length <= 1) return; // Keep at least one state
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Remove current state
    undoHistoryRef.current.pop();
    
    // Get previous state
    const previousState = undoHistoryRef.current[undoHistoryRef.current.length - 1];
    
    // Restore previous state
    const img = new Image();
    img.onload = () => {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      ctx.drawImage(img, 0, 0, rect.width, rect.height);
    };
    img.src = previousState;
    
    setCanUndo(undoHistoryRef.current.length > 1);
  };
  
  const applySymmetry = (ctx, x, y, drawFunction) => {
    // Calculate viewport center in canvas coordinates
    // Get actual canvas position after CSS transform
    const rect = canvasRef.current.getBoundingClientRect();
    const centerX = (window.innerWidth / 2 - rect.left) / canvasZoom;
    const centerY = (window.innerHeight / 2 - rect.top) / canvasZoom;
    
    if (symmetryMode === 'none') {
      drawFunction(x, y);
    } else if (symmetryMode === 'mirror') {
      // Draw original
      drawFunction(x, y);
      
      // Calculate mirror reflection across line at given angle
      const angleRad = (mirrorAngle * Math.PI) / 180;
      
      // Translate point relative to center
      const relX = x - centerX;
      const relY = y - centerY;
      
      // Reflect across line at angle using reflection matrix
      const cos2a = Math.cos(2 * angleRad);
      const sin2a = Math.sin(2 * angleRad);
      
      const mirrorX = relX * cos2a + relY * sin2a;
      const mirrorY = relX * sin2a - relY * cos2a;
      
      // Translate back
      const finalX = mirrorX + centerX;
      const finalY = mirrorY + centerY;
      
      drawFunction(finalX, finalY);
    }
  };
  
  // Bleed animation effect - works with any brush or shape
  useEffect(() => {
    if (!isHolding || !bleedEnabled) {
      if (bleedAnimationRef.current) {
        cancelAnimationFrame(bleedAnimationRef.current);
        bleedAnimationRef.current = null;
      }
      return;
    }
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const state = bleedStateRef.current;
    
    const animate = () => {
      if (!isHolding || !bleedEnabled) return;
      
      // Increase radius over time
      state.radius += 1.5;
      
      if (state.radius > state.maxRadius) {
        state.radius = state.maxRadius;
      }
      
      // Wrap bleed drawing in symmetry function
      const drawBleedPattern = (bx, by) => {
        // Draw the selected brush pattern or shape at expanding radius
        if (shapeMode) {
          // For shapes, draw them at the expanding radius in a circle
          const numShapes = Math.floor(state.radius / (brushSize * 0.5));
          if (numShapes > 0 && state.radius % (brushSize * 0.5) < 2) {
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              const x = bx + Math.cos(angle) * state.radius;
              const y = by + Math.sin(angle) * state.radius;
              drawShape(ctx, x, y, shapeMode);
            }
          }
        } else {
          // For brush modes, create emanating patterns
          ctx.globalAlpha = opacity;
          
          if (brushMode === 'segments') {
            // Expanding segmented circles
            const numSegments = 24;
            ctx.strokeStyle = selectedColor;
            ctx.lineWidth = lineWeight;
            ctx.lineCap = 'round';
            
            for (let i = 0; i < numSegments; i++) {
              const angle = (i / numSegments) * Math.PI * 2;
              const startAngle = angle - 0.1;
              const endAngle = angle + 0.1;
              ctx.beginPath();
              ctx.arc(bx, by, state.radius, startAngle, endAngle);
              ctx.stroke();
            }
          } else if (brushMode === 'dots') {
            // Expanding rings of evenly-spaced dots
            ctx.fillStyle = selectedColor;
            
            // Draw multiple concentric rings
            const numRings = Math.floor(state.radius / 15);
            for (let ring = 1; ring <= numRings; ring++) {
              const ringRadius = ring * 15;
              if (ringRadius > state.radius) break;
              
              // Fixed number of dots per ring for geometric consistency
              const dotsPerRing = 12 * ring;
              for (let i = 0; i < dotsPerRing; i++) {
                const angle = (i / dotsPerRing) * Math.PI * 2;
                const dotX = bx + Math.cos(angle) * ringRadius;
                const dotY = by + Math.sin(angle) * ringRadius;
                ctx.beginPath();
                ctx.arc(dotX, dotY, lineWeight, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else if (brushMode === 'radials') {
            // Radiating lines outward
            const numLines = 16;
            ctx.strokeStyle = selectedColor;
            ctx.lineWidth = lineWeight * 0.5;
            
            for (let i = 0; i < numLines; i++) {
              const angle = (i / numLines) * Math.PI * 2;
              const innerRadius = state.radius - 10;
              const outerRadius = state.radius;
              ctx.beginPath();
              ctx.moveTo(
                bx + Math.cos(angle) * innerRadius,
                by + Math.sin(angle) * innerRadius
              );
              ctx.lineTo(
                bx + Math.cos(angle) * outerRadius,
                by + Math.sin(angle) * outerRadius
              );
              ctx.stroke();
            }
          } else if (brushMode === 'crosshatch') {
            // Expanding crosshatch circle
            const numLines = Math.floor(state.radius / 8);
            ctx.strokeStyle = selectedColor;
            ctx.lineWidth = lineWeight * 0.7;
            
            for (let i = 0; i < numLines; i++) {
              const angle = (i / numLines) * Math.PI * 2;
              const x = bx + Math.cos(angle) * state.radius;
              const y = by + Math.sin(angle) * state.radius;
              const perpAngle = angle + Math.PI / 2;
              const length = brushSize * 0.3;
              
              ctx.beginPath();
              ctx.moveTo(
                x + Math.cos(perpAngle) * length / 2,
                y + Math.sin(perpAngle) * length / 2
              );
              ctx.lineTo(
                x - Math.cos(perpAngle) * length / 2,
                y - Math.sin(perpAngle) * length / 2
              );
              ctx.stroke();
            }
          } else if (brushMode === 'stipple') {
            // Concentric rings of stippled clusters
            ctx.fillStyle = selectedColor;
            
            // Draw multiple concentric rings of clusters
            const numRings = Math.floor(state.radius / 20);
            for (let ring = 1; ring <= numRings; ring++) {
              const ringRadius = ring * 20;
              if (ringRadius > state.radius) break;
              
              // Fixed number of clusters per ring
              const clustersPerRing = 8 * ring;
              for (let i = 0; i < clustersPerRing; i++) {
                const angle = (i / clustersPerRing) * Math.PI * 2;
                const centerX = bx + Math.cos(angle) * ringRadius;
                const centerY = by + Math.sin(angle) * ringRadius;
                
                // Create small cluster at each position
                for (let j = 0; j < 3; j++) {
                  const offsetX = (Math.random() - 0.5) * brushSize * 0.15;
                  const offsetY = (Math.random() - 0.5) * brushSize * 0.15;
                  ctx.beginPath();
                  ctx.arc(centerX + offsetX, centerY + offsetY, lineWeight * 0.5, 0, Math.PI * 2);
                  ctx.fill();
                }
              }
            }
          } else if (brushMode === 'fine') {
            // Simple expanding circle
            ctx.strokeStyle = selectedColor;
            ctx.lineWidth = lineWeight;
            ctx.beginPath();
            ctx.arc(bx, by, state.radius, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          ctx.globalAlpha = 1;
        }
      };
      
      // Apply symmetry to bleed pattern
      applySymmetry(ctx, state.x, state.y, drawBleedPattern);
      
      bleedAnimationRef.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    return () => {
      if (bleedAnimationRef.current) {
        cancelAnimationFrame(bleedAnimationRef.current);
      }
    };
  }, [isHolding, bleedEnabled, brushMode, shapeMode, selectedColor, opacity, lineWeight, brushSize, symmetryMode, mirrorAngle]);
  
  const hexToRgba = (hex, alpha) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  };
  
  const drawBlend = (ctx, x, y, lastX, lastY) => {
    // Smudge/blend the pixels underneath
    const blendRadius = brushSize * 0.5;
    const dx = x - lastX;
    const dy = y - lastY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < 1) return;
    
    try {
      const dpr = window.devicePixelRatio || 1;
      
      // Convert CSS pixels to device pixels for sampling
      const deviceLastX = lastX * dpr;
      const deviceLastY = lastY * dpr;
      const deviceBlendRadius = blendRadius * dpr;
      
      // Sample the area we're about to smudge
      const sourceX = Math.max(0, Math.floor(deviceLastX - deviceBlendRadius));
      const sourceY = Math.max(0, Math.floor(deviceLastY - deviceBlendRadius));
      const sourceWidth = Math.min(ctx.canvas.width - sourceX, Math.ceil(deviceBlendRadius * 2));
      const sourceHeight = Math.min(ctx.canvas.height - sourceY, Math.ceil(deviceBlendRadius * 2));
      
      if (sourceWidth <= 0 || sourceHeight <= 0) return;
      
      const imageData = ctx.getImageData(sourceX, sourceY, sourceWidth, sourceHeight);
      
      // Draw the sampled pixels slightly offset in the direction of movement
      const smudgeStrength = 0.5;
      const offsetX = dx * dpr * smudgeStrength;
      const offsetY = dy * dpr * smudgeStrength;
      
      ctx.globalAlpha = opacity * 0.8;
      ctx.putImageData(imageData, sourceX + offsetX, sourceY + offsetY);
      ctx.globalAlpha = 1;
    } catch (e) {
      // Handle edge cases silently
      console.error('Blend error:', e);
    }
  };
  
  const floodFill = (ctx, startX, startY, fillColor) => {
    const canvas = ctx.canvas;
    const dpr = window.devicePixelRatio || 1;
    
    // Show notification for potentially slow fills
    setFillNotification(true);
    
    // Use setTimeout to allow notification to render before blocking operation
    // 200ms ensures the notification is visible during the "thinking" pause
    setTimeout(() => {
      try {
        performFloodFill(ctx, startX, startY, fillColor);
      } finally {
        setFillNotification(false);
      }
    }, 200);
  };
  
  const performFloodFill = (ctx, startX, startY, fillColor) => {
    const canvas = ctx.canvas;
    const dpr = window.devicePixelRatio || 1;
    
    // Convert CSS pixel coordinates to device pixel coordinates
    const deviceX = Math.floor(startX * dpr);
    const deviceY = Math.floor(startY * dpr);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;
    
    const startPos = (deviceY * canvas.width + deviceX) * 4;
    
    // Check if coordinates are valid
    if (deviceX < 0 || deviceX >= canvas.width || deviceY < 0 || deviceY >= canvas.height) {
      return;
    }
    
    const startR = pixels[startPos];
    const startG = pixels[startPos + 1];
    const startB = pixels[startPos + 2];
    const startA = pixels[startPos + 3];
    
    // Convert fill color to RGB
    const fillRgb = hexToRgb(fillColor);
    const fillR = fillRgb.r;
    const fillG = fillRgb.g;
    const fillB = fillRgb.b;
    const fillA = Math.floor(opacity * 255);
    
    // Don't fill if the color is the same
    if (startR === fillR && startG === fillG && startB === fillB && startA === fillA) {
      return;
    }
    
    // Fast path for large background fills
    // Check if we're clicking on the background color (black: #0a0a0a)
    const isBackgroundColor = (startR === 10 && startG === 10 && startB === 10);
    
    // Count how many pixels around the click point have the same color
    // If it's a large connected area, use fast fill instead of flood fill
    let sameColorCount = 0;
    const sampleRadius = 50;
    for (let dy = -sampleRadius; dy <= sampleRadius; dy += 10) {
      for (let dx = -sampleRadius; dx <= sampleRadius; dx += 10) {
        const checkX = deviceX + dx;
        const checkY = deviceY + dy;
        if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
          const checkPos = (checkY * width + checkX) * 4;
          if (pixels[checkPos] === startR && pixels[checkPos + 1] === startG && 
              pixels[checkPos + 2] === startB && pixels[checkPos + 3] === startA) {
            sameColorCount++;
          }
        }
      }
    }
    
    // If clicking on background and >80% of nearby area is same color, it's a large fill
    const sampledPoints = Math.pow((sampleRadius * 2 / 10) + 1, 2);
    if (isBackgroundColor && sameColorCount > sampledPoints * 0.8) {
      // Fast fill entire canvas background
      ctx.fillStyle = fillColor;
      ctx.globalAlpha = opacity;
      const rect = canvas.getBoundingClientRect();
      ctx.fillRect(0, 0, rect.width, rect.height);
      ctx.globalAlpha = 1;
      return;
    }
    
    // For pattern fills, create pattern first
    let patternCanvas = null;
    if (fillPattern !== 'solid') {
      patternCanvas = createPatternCanvas(fillColor);
    }
    
    const pixelsToCheck = [deviceX, deviceY];
    const width = canvas.width;
    const height = canvas.height;
    const visited = new Uint8Array(width * height);
    
    // Optimization: limit iterations for very large fills
    let pixelsProcessed = 0;
    const maxPixels = 5000000; // Stop after 5 million pixels (~15% of canvas)
    
    while (pixelsToCheck.length > 0 && pixelsProcessed < maxPixels) {
      const y = pixelsToCheck.pop();
      const x = pixelsToCheck.pop();
      
      if (x < 0 || x >= width || y < 0 || y >= height) continue;
      
      const currentPos = y * width + x;
      if (visited[currentPos]) continue;
      visited[currentPos] = 1;
      pixelsProcessed++;
      
      const pixelPos = currentPos * 4;
      
      // Check if pixel matches start color
      if (
        pixels[pixelPos] === startR &&
        pixels[pixelPos + 1] === startG &&
        pixels[pixelPos + 2] === startB &&
        pixels[pixelPos + 3] === startA
      ) {
        // Fill this pixel
        if (fillPattern === 'solid') {
          pixels[pixelPos] = fillR;
          pixels[pixelPos + 1] = fillG;
          pixels[pixelPos + 2] = fillB;
          pixels[pixelPos + 3] = fillA;
        } else if (patternCanvas) {
          // Apply rotation to sampling coordinates
          const angle = (fillPatternRotation * Math.PI) / 180;
          const centerX = width / 2;
          const centerY = height / 2;
          
          // Translate to center, rotate, translate back
          const dx = x - centerX;
          const dy = y - centerY;
          const rotatedX = dx * Math.cos(-angle) - dy * Math.sin(-angle) + centerX;
          const rotatedY = dx * Math.sin(-angle) + dy * Math.cos(-angle) + centerY;
          
          // Sample from pattern using rotated coordinates
          const patternX = Math.floor(rotatedX) % patternCanvas.width;
          const patternY = Math.floor(rotatedY) % patternCanvas.height;
          
          // Handle negative modulo
          const finalPatternX = patternX < 0 ? patternX + patternCanvas.width : patternX;
          const finalPatternY = patternY < 0 ? patternY + patternCanvas.height : patternY;
          
          const patternData = patternCanvas.getContext('2d').getImageData(
            finalPatternX,
            finalPatternY,
            1, 1
          ).data;
          pixels[pixelPos] = patternData[0];
          pixels[pixelPos + 1] = patternData[1];
          pixels[pixelPos + 2] = patternData[2];
          pixels[pixelPos + 3] = patternData[3];
        }
        
        // Add neighboring pixels
        pixelsToCheck.push(x + 1, y);
        pixelsToCheck.push(x - 1, y);
        pixelsToCheck.push(x, y + 1);
        pixelsToCheck.push(x, y - 1);
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
  };
  
  const hexToRgb = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
  };
  
  // Color extraction from image using Median Cut algorithm
  const extractColorsFromImage = (imageData, colorCount = 16) => {
    const pixels = [];
    const data = imageData.data;
    
    // Sample pixels (use every 10th pixel for performance)
    for (let i = 0; i < data.length; i += 40) {
      pixels.push([data[i], data[i + 1], data[i + 2]]);
    }
    
    // Median cut algorithm
    const medianCut = (pixels, depth) => {
      if (depth === 0 || pixels.length === 0) {
        // Calculate average color
        const total = pixels.reduce((acc, p) => {
          acc[0] += p[0];
          acc[1] += p[1];
          acc[2] += p[2];
          return acc;
        }, [0, 0, 0]);
        
        return [{
          r: Math.round(total[0] / pixels.length),
          g: Math.round(total[1] / pixels.length),
          b: Math.round(total[2] / pixels.length)
        }];
      }
      
      // Find the color channel with the greatest range
      const ranges = [0, 1, 2].map(i => {
        const values = pixels.map(p => p[i]);
        return Math.max(...values) - Math.min(...values);
      });
      
      const maxChannel = ranges.indexOf(Math.max(...ranges));
      
      // Sort by that channel
      pixels.sort((a, b) => a[maxChannel] - b[maxChannel]);
      
      // Split in half
      const mid = Math.floor(pixels.length / 2);
      const left = pixels.slice(0, mid);
      const right = pixels.slice(mid);
      
      // Recurse
      return [
        ...medianCut(left, depth - 1),
        ...medianCut(right, depth - 1)
      ];
    };
    
    const depth = Math.log2(colorCount);
    return medianCut(pixels, depth);
  };
  
  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        // Create temporary canvas to extract colors
        const tempCanvas = document.createElement('canvas');
        const maxSize = 200; // Limit size for performance
        const scale = Math.min(1, maxSize / Math.max(img.width, img.height));
        
        tempCanvas.width = img.width * scale;
        tempCanvas.height = img.height * scale;
        
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
        
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const colors = extractColorsFromImage(imageData, 16);
        
        // Convert to hex and create palette
        const paletteColors = colors.map((c, i) => ({
          name: `Color ${i + 1}`,
          color: `#${c.r.toString(16).padStart(2, '0')}${c.g.toString(16).padStart(2, '0')}${c.b.toString(16).padStart(2, '0')}`
        }));
        
        // Add to custom palettes
        const customNumber = Object.keys(customPalettes).filter(k => k.startsWith('custom')).length + 1;
        const paletteName = `custom${customNumber}`;
        
        setCustomPalettes(prev => ({
          ...prev,
          [paletteName]: {
            name: `Custom ${customNumber}`,
            colors: paletteColors
          }
        }));
        
        // Switch to the new palette
        setCurrentPalette(paletteName);
      };
      
      img.src = event.target.result;
    };
    
    reader.readAsDataURL(file);
  };
  
  const createPatternCanvas = (color) => {
    const patternCanvas = document.createElement('canvas');
    const size = 20;
    patternCanvas.width = size;
    patternCanvas.height = size;
    const pctx = patternCanvas.getContext('2d');
    
    // Start with transparent background - no base fill
    // Do NOT rotate here - rotation will be applied when using the pattern
    pctx.strokeStyle = color;
    pctx.fillStyle = color;
    pctx.globalAlpha = opacity;
    
    // Calculate spacing based on density (10-100)
    // Remapped so current "58" level is the maximum (100)
    // Lower density = much more sparse than before
    const densityFactor = (fillPatternDensity / 100) * 1.2; // 0.12 to 1.2
    
    if (fillPattern === 'dots') {
      // Dotted pattern
      const spacing = Math.max(3, 6 / densityFactor);
      for (let x = 0; x < size; x += spacing) {
        for (let y = 0; y < size; y += spacing) {
          pctx.beginPath();
          pctx.arc(x, y, 1, 0, Math.PI * 2);
          pctx.fill();
        }
      }
    } else if (fillPattern === 'lines') {
      // Horizontal lines
      pctx.lineWidth = 1;
      const spacing = Math.max(2, 4 / densityFactor);
      for (let y = 0; y < size; y += spacing) {
        pctx.beginPath();
        pctx.moveTo(0, y);
        pctx.lineTo(size, y);
        pctx.stroke();
      }
    } else if (fillPattern === 'crosshatch') {
      // Crosshatch pattern
      pctx.lineWidth = 1;
      const spacing = Math.max(2, 4 / densityFactor);
      for (let i = 0; i < size; i += spacing) {
        pctx.beginPath();
        pctx.moveTo(0, i);
        pctx.lineTo(size, i);
        pctx.stroke();
        
        pctx.beginPath();
        pctx.moveTo(i, 0);
        pctx.lineTo(i, size);
        pctx.stroke();
      }
    } else if (fillPattern === 'stipple') {
      // Random stipple
      const numDots = Math.floor(20 * densityFactor);
      for (let i = 0; i < numDots; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        pctx.beginPath();
        pctx.arc(x, y, 0.5, 0, Math.PI * 2);
        pctx.fill();
      }
    } else if (fillPattern === 'mesh') {
      // New mesh/grid pattern
      pctx.lineWidth = 0.5;
      const spacing = Math.max(2, 5 / densityFactor);
      // Vertical lines
      for (let x = 0; x < size; x += spacing) {
        pctx.beginPath();
        pctx.moveTo(x, 0);
        pctx.lineTo(x, size);
        pctx.stroke();
      }
      // Horizontal lines
      for (let y = 0; y < size; y += spacing) {
        pctx.beginPath();
        pctx.moveTo(0, y);
        pctx.lineTo(size, y);
        pctx.stroke();
      }
    }
    
    return patternCanvas;
  };
  
  const drawShape = (ctx, x, y, shape) => {
    ctx.globalAlpha = opacity;
    const color = selectedColor;
    
    if (shape === 'concentric') {
      // Concentric circles like in the images
      const numRings = Math.floor(brushSize / 8);
      for (let i = 0; i < numRings; i++) {
        const radius = (i + 1) * (brushSize / numRings);
        const ringOpacity = opacity * (1 - i / numRings);
        
        if (shapeFilled) {
          ctx.fillStyle = hexToRgba(color, ringOpacity);
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.strokeStyle = hexToRgba(color, ringOpacity);
          ctx.lineWidth = lineWeight;
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    } else if (shape === 'radial') {
      // Radiating lines like sunburst
      const numLines = 24;
      ctx.strokeStyle = hexToRgba(color, opacity);
      ctx.lineWidth = lineWeight;
      for (let i = 0; i < numLines; i++) {
        const angle = (i / numLines) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(
          x + Math.cos(angle) * brushSize,
          y + Math.sin(angle) * brushSize
        );
        ctx.stroke();
      }
    } else if (shape === 'mesh') {
      // Mesh/lattice circle
      if (shapeFilled) {
        // Just draw filled circle
        ctx.fillStyle = hexToRgba(color, opacity);
        ctx.beginPath();
        ctx.arc(x, y, brushSize, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Draw mesh pattern
        const numSegments = 16;
        ctx.strokeStyle = hexToRgba(color, opacity * 0.6);
        ctx.lineWidth = lineWeight * 0.5;
        
        // Outer circle
        ctx.beginPath();
        ctx.arc(x, y, brushSize, 0, Math.PI * 2);
        ctx.stroke();
        
        // Internal web pattern
        for (let i = 0; i < numSegments; i++) {
          const angle = (i / numSegments) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(
            x + Math.cos(angle) * brushSize,
            y + Math.sin(angle) * brushSize
          );
          ctx.stroke();
        }
        
        // Inner rings
        ctx.beginPath();
        ctx.arc(x, y, brushSize * 0.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, brushSize * 0.25, 0, Math.PI * 2);
        ctx.stroke();
      }
    } else if (shape === 'dotted') {
      // Dotted circle pattern
      const numDots = Math.floor(brushSize / 3);
      ctx.fillStyle = hexToRgba(color, opacity);
      for (let i = 0; i < numDots; i++) {
        const angle = (i / numDots) * Math.PI * 2;
        const dotX = x + Math.cos(angle) * brushSize;
        const dotY = y + Math.sin(angle) * brushSize;
        ctx.beginPath();
        ctx.arc(dotX, dotY, lineWeight * 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (shape === 'circle') {
      // Simple circle
      if (shapeFilled) {
        ctx.fillStyle = hexToRgba(color, opacity);
        ctx.beginPath();
        ctx.arc(x, y, brushSize, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.strokeStyle = hexToRgba(color, opacity);
        ctx.lineWidth = lineWeight;
        ctx.beginPath();
        ctx.arc(x, y, brushSize, 0, Math.PI * 2);
        ctx.stroke();
      }
    } else if (shape === 'mandala') {
      // Sacred geometry mandala pattern
      const layers = 3;
      const petals = 8;
      ctx.lineWidth = lineWeight;
      
      if (shapeFilled) {
        ctx.fillStyle = hexToRgba(color, opacity);
        for (let layer = 1; layer <= layers; layer++) {
          const radius = (brushSize / layers) * layer;
          for (let i = 0; i < petals; i++) {
            const angle = (i / petals) * Math.PI * 2;
            const petalX = x + Math.cos(angle) * radius;
            const petalY = y + Math.sin(angle) * radius;
            
            ctx.beginPath();
            ctx.arc(petalX, petalY, radius / 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Center
        ctx.beginPath();
        ctx.arc(x, y, brushSize / 6, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.strokeStyle = hexToRgba(color, opacity);
        for (let layer = 1; layer <= layers; layer++) {
          const radius = (brushSize / layers) * layer;
          for (let i = 0; i < petals; i++) {
            const angle = (i / petals) * Math.PI * 2;
            const petalX = x + Math.cos(angle) * radius;
            const petalY = y + Math.sin(angle) * radius;
            
            ctx.beginPath();
            ctx.arc(petalX, petalY, radius / 3, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
        
        // Center
        ctx.beginPath();
        ctx.arc(x, y, brushSize / 6, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    ctx.globalAlpha = 1;
  };
  
  const startDrawing = (e) => {
    const { x, y } = screenToCanvas(e.clientX, e.clientY);
    
    // If in fill mode, perform flood fill with symmetry
    if (fillMode) {
      const ctx = canvasRef.current.getContext('2d');
      applySymmetry(ctx, x, y, (sx, sy) => {
        floodFill(ctx, sx, sy, selectedColor);
      });
      saveToHistory();
      return;
    }
    
    // If bleed is enabled, start the bleed animation and drawing
    if (bleedEnabled) {
      bleedStateRef.current = {
        x,
        y,
        radius: 0,
        maxRadius: brushSize * 4
      };
      setIsHolding(true);
      setIsDrawing(true);
      lastPosRef.current = { x, y };
      return;
    }
    
    // If in shape mode, draw shape with symmetry
    if (shapeMode) {
      const ctx = canvasRef.current.getContext('2d');
      applySymmetry(ctx, x, y, (sx, sy) => {
        drawShape(ctx, sx, sy, shapeMode);
      });
      saveToHistory();
      return;
    }
    
    setIsDrawing(true);
    lastPosRef.current = { x, y };
  };
  
  const draw = (e) => {
    if ((!isDrawing && !isHolding) || shapeMode) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const { x, y } = screenToCanvas(e.clientX, e.clientY);
    
    // If bleed is enabled, update the bleed center position as cursor moves
    if (bleedEnabled && isHolding) {
      const dx = x - lastPosRef.current.x;
      const dy = y - lastPosRef.current.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // If cursor moved significantly, update bleed center and reset radius for trailing effect
      if (distance > 5) {
        bleedStateRef.current.x = x;
        bleedStateRef.current.y = y;
        // Reduce radius slightly when moving for a trailing effect
        bleedStateRef.current.radius = Math.max(0, bleedStateRef.current.radius * 0.7);
      }
      
      lastPosRef.current = { x, y };
      return;
    }
    
    // If in blend mode, smudge the pixels with symmetry
    if (blendMode) {
      applySymmetry(ctx, x, y, (sx, sy) => {
        // Calculate corresponding lastPos for mirrored point
        // Get actual canvas position after CSS transform
        const rect = canvasRef.current.getBoundingClientRect();
        const centerX = (window.innerWidth / 2 - rect.left) / canvasZoom;
        const centerY = (window.innerHeight / 2 - rect.top) / canvasZoom;
        
        let lastSx = lastPosRef.current.x;
        let lastSy = lastPosRef.current.y;
        
        if (symmetryMode === 'mirror') {
          // Check if this is the mirrored point
          const angleRad = (mirrorAngle * Math.PI) / 180;
          const relX = sx - centerX;
          const relY = sy - centerY;
          
          // Compare with original point
          const origRelX = x - centerX;
          const origRelY = y - centerY;
          
          // If this isn't the original point, it's the mirror
          const isMirror = Math.abs(relX - origRelX) > 1 || Math.abs(relY - origRelY) > 1;
          
          if (isMirror) {
            // Mirror the lastPos as well
            const lastRelX = lastPosRef.current.x - centerX;
            const lastRelY = lastPosRef.current.y - centerY;
            
            const cos2a = Math.cos(2 * angleRad);
            const sin2a = Math.sin(2 * angleRad);
            
            const mirrorLastX = lastRelX * cos2a + lastRelY * sin2a;
            const mirrorLastY = lastRelX * sin2a - lastRelY * cos2a;
            
            lastSx = mirrorLastX + centerX;
            lastSy = mirrorLastY + centerY;
          }
        }
        
        drawBlend(ctx, sx, sy, lastSx, lastSy);
      });
      lastPosRef.current = { x, y };
      return;
    }
    
    // Apply symmetry to all brush modes
    applySymmetry(ctx, x, y, (sx, sy) => {
      // Store original lastPos
      const origLastX = lastPosRef.current.x;
      const origLastY = lastPosRef.current.y;
      
      // Calculate symmetry-adjusted lastPos
      // Get actual canvas position after CSS transform
      const rect = canvasRef.current.getBoundingClientRect();
      const centerX = (window.innerWidth / 2 - rect.left) / canvasZoom;
      const centerY = (window.innerHeight / 2 - rect.top) / canvasZoom;
      
      let lastSx = origLastX;
      let lastSy = origLastY;
      
      if (symmetryMode === 'mirror') {
        // Check if this is the mirrored point
        const relX = sx - centerX;
        const relY = sy - centerY;
        const origRelX = x - centerX;
        const origRelY = y - centerY;
        
        const isMirror = Math.abs(relX - origRelX) > 1 || Math.abs(relY - origRelY) > 1;
        
        if (isMirror) {
          // Mirror the lastPos
          const angleRad = (mirrorAngle * Math.PI) / 180;
          const lastRelX = origLastX - centerX;
          const lastRelY = origLastY - centerY;
          
          const cos2a = Math.cos(2 * angleRad);
          const sin2a = Math.sin(2 * angleRad);
          
          const mirrorLastX = lastRelX * cos2a + lastRelY * sin2a;
          const mirrorLastY = lastRelX * sin2a - lastRelY * cos2a;
          
          lastSx = mirrorLastX + centerX;
          lastSy = mirrorLastY + centerY;
        }
      }
      
      // Temporarily set lastPos for this symmetry instance
      const tempLastPos = { x: lastSx, y: lastSy };
      lastPosRef.current = tempLastPos;
      
      // Draw with this symmetry instance
      drawBrushStroke(ctx, sx, sy);
      
      // Restore original lastPos
      lastPosRef.current = { x: origLastX, y: origLastY };
    });
    
    lastPosRef.current = { x, y };
  };
  
  // Extract brush drawing logic into separate function
  const drawBrushStroke = (ctx, x, y) => {
    
    const dx = x - lastPosRef.current.x;
    const dy = y - lastPosRef.current.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    
    ctx.globalAlpha = opacity;
    
    if (brushMode === 'segments') {
      // Segmented dashed lines
      const segmentLength = 5;
      const gapLength = 5;
      let currentDist = 0;
      let drawing = true;
      
      ctx.strokeStyle = selectedColor;
      ctx.lineWidth = lineWeight;
      ctx.lineCap = 'round';
      
      while (currentDist < distance) {
        const t = currentDist / distance;
        const px = lastPosRef.current.x + dx * t;
        const py = lastPosRef.current.y + dy * t;
        
        if (drawing) {
          const endDist = Math.min(currentDist + segmentLength, distance);
          const endT = endDist / distance;
          const endX = lastPosRef.current.x + dx * endT;
          const endY = lastPosRef.current.y + dy * endT;
          
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(endX, endY);
          ctx.stroke();
          
          currentDist += segmentLength;
        } else {
          currentDist += gapLength;
        }
        drawing = !drawing;
      }
    } else if (brushMode === 'dots') {
      // Fine dotted trail - closer spacing like fine lines
      const dotSpacing = 3; // Much closer spacing
      const numDots = Math.floor(distance / dotSpacing);
      
      ctx.fillStyle = selectedColor;
      
      for (let i = 0; i <= numDots; i++) {
        const t = i / Math.max(numDots, 1);
        const px = lastPosRef.current.x + dx * t;
        const py = lastPosRef.current.y + dy * t;
        
        // Consistent dot size like fine line weight
        const dotSize = lineWeight;
        
        ctx.beginPath();
        ctx.arc(px, py, dotSize, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (brushMode === 'radials') {
      // Small radial bursts along the path
      const burstSpacing = 20;
      const numBursts = Math.floor(distance / burstSpacing);
      
      ctx.strokeStyle = selectedColor;
      ctx.lineWidth = lineWeight * 0.5;
      
      for (let i = 0; i <= numBursts; i++) {
        const t = i / Math.max(numBursts, 1);
        const px = lastPosRef.current.x + dx * t;
        const py = lastPosRef.current.y + dy * t;
        
        const numLines = 8;
        const burstSize = brushSize * 0.3;
        
        for (let j = 0; j < numLines; j++) {
          const burstAngle = (j / numLines) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.lineTo(
            px + Math.cos(burstAngle) * burstSize,
            py + Math.sin(burstAngle) * burstSize
          );
          ctx.stroke();
        }
      }
    } else if (brushMode === 'crosshatch') {
      // Delicate crosshatch pattern
      const hatchSpacing = 15;
      const numHatches = Math.floor(distance / hatchSpacing);
      
      ctx.strokeStyle = selectedColor;
      ctx.lineWidth = lineWeight * 0.7;
      
      for (let i = 0; i <= numHatches; i++) {
        const t = i / Math.max(numHatches, 1);
        const px = lastPosRef.current.x + dx * t;
        const py = lastPosRef.current.y + dy * t;
        
        const hatchLength = brushSize * 0.4;
        
        // Perpendicular lines
        const perpAngle = angle + Math.PI / 2;
        ctx.beginPath();
        ctx.moveTo(
          px + Math.cos(perpAngle) * hatchLength / 2,
          py + Math.sin(perpAngle) * hatchLength / 2
        );
        ctx.lineTo(
          px - Math.cos(perpAngle) * hatchLength / 2,
          py - Math.sin(perpAngle) * hatchLength / 2
        );
        ctx.stroke();
        
        // Crossing lines at angle
        const crossAngle = angle + Math.PI / 4;
        ctx.beginPath();
        ctx.moveTo(
          px + Math.cos(crossAngle) * hatchLength / 2,
          py + Math.sin(crossAngle) * hatchLength / 2
        );
        ctx.lineTo(
          px - Math.cos(crossAngle) * hatchLength / 2,
          py - Math.sin(crossAngle) * hatchLength / 2
        );
        ctx.stroke();
      }
    } else if (brushMode === 'stipple') {
      // Stippled cluster of dots
      const numDots = Math.floor(distance * 0.5);
      ctx.fillStyle = selectedColor;
      
      for (let i = 0; i < numDots; i++) {
        const t = i / numDots;
        const centerX = lastPosRef.current.x + dx * t;
        const centerY = lastPosRef.current.y + dy * t;
        
        // Random offset from center
        const offsetX = (Math.random() - 0.5) * brushSize;
        const offsetY = (Math.random() - 0.5) * brushSize;
        
        const dotSize = lineWeight * 0.5 * (0.5 + Math.random() * 0.5);
        
        ctx.beginPath();
        ctx.arc(centerX + offsetX, centerY + offsetY, dotSize, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (brushMode === 'fine') {
      // Fine continuous line
      ctx.strokeStyle = selectedColor;
      ctx.lineWidth = lineWeight;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      ctx.beginPath();
      ctx.moveTo(lastPosRef.current.x, lastPosRef.current.y);
      ctx.lineTo(x, y);
      ctx.stroke();
    }
    
    ctx.globalAlpha = 1;
    // Note: lastPos is managed by the caller
  };
  
  const stopDrawing = () => {
    if (isDrawing || isHolding) {
      saveToHistory();
    }
    setIsDrawing(false);
    setIsHolding(false);
  };
  
  // Touch event handlers for mobile/tablet support
  const handleTouchStart = (e) => {
    e.preventDefault(); // Prevent scrolling
    
    if (e.touches.length === 2) {
      // Two fingers - start panning
      setIsPanning(true);
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const centerX = (touch1.clientX + touch2.clientX) / 2;
      const centerY = (touch1.clientY + touch2.clientY) / 2;
      setPanStart({ x: centerX - canvasPan.x, y: centerY - canvasPan.y });
    } else if (e.touches.length === 1 && !isPanning) {
      // One finger - draw
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      startDrawing(mouseEvent);
    }
  };
  
  const handleTouchMove = (e) => {
    e.preventDefault(); // Prevent scrolling
    
    if (e.touches.length === 2 && isPanning) {
      // Two fingers - pan canvas
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const centerX = (touch1.clientX + touch2.clientX) / 2;
      const centerY = (touch1.clientY + touch2.clientY) / 2;
      setCanvasPan({
        x: centerX - panStart.x,
        y: centerY - panStart.y
      });
    } else if (e.touches.length === 1 && !isPanning) {
      // One finger - draw
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      draw(mouseEvent);
    }
  };
  
  const handleTouchEnd = (e) => {
    e.preventDefault(); // Prevent scrolling
    
    if (e.touches.length < 2) {
      setIsPanning(false);
    }
    
    if (e.touches.length === 0) {
      const mouseEvent = new MouseEvent('mouseup', {});
      stopDrawing(mouseEvent);
    }
  };
  
  const clearCanvas = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    
    // Clear entire canvas (not just viewport)
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
    
    // Clear undo history and save new blank state
    undoHistoryRef.current = [];
    saveToHistory();
    setCanUndo(false);
  };
  
  const saveImage = () => {
    const canvas = canvasRef.current;
    const link = document.createElement('a');
    link.download = 'geometric-art.png';
    link.href = canvas.toDataURL();
    link.click();
  };
  
  const saveAsJPEG = () => {
    const canvas = canvasRef.current;
    const link = document.createElement('a');
    link.download = 'geometric-art.jpg';
    link.href = canvas.toDataURL('image/jpeg', 0.95);
    link.click();
  };

  return (
    <div style={{
      width: '100vw',
      height: '100vh',
      overflow: 'hidden',
      background: '#1a1a1a',  // Dark gray background so black canvas stands out
      fontFamily: '"Crimson Pro", "Cormorant Garamond", serif',
      position: 'relative'
    }}>
      <canvas
        ref={canvasRef}
        onMouseDown={startDrawing}
        onMouseMove={draw}
        onMouseUp={stopDrawing}
        onMouseLeave={stopDrawing}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onTouchCancel={handleTouchEnd}
        style={{ 
          display: 'block',
          cursor: 'crosshair',
          touchAction: 'none', // Prevent default touch behaviors
          transform: `translate(${canvasPan.x}px, ${canvasPan.y}px) scale(${canvasZoom})`,
          transformOrigin: '0 0',  // Scale from top-left for simpler math
          transition: isPanning ? 'none' : 'transform 0.2s ease'
        }}
      />
      
      {/* Fill Notification */}
      {fillNotification && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'rgba(10, 20, 30, 0.95)',
          backdropFilter: 'blur(20px)',
          border: '2px solid rgba(107, 181, 199, 0.6)',
          borderRadius: '15px',
          padding: '20px 40px',
          color: '#6bb5c7',
          fontSize: '16px',
          fontWeight: '600',
          letterSpacing: '1px',
          textAlign: 'center',
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.5), 0 0 60px rgba(107, 181, 199, 0.2)',
          zIndex: 3000,
          animation: 'pulse 1.5s ease-in-out infinite'
        }}>
          <div style={{ marginBottom: '8px', fontSize: '24px' }}></div>
          <div>Filling...</div>
          <div style={{ fontSize: '12px', opacity: 0.7, marginTop: '5px' }}>
            This may take a moment
          </div>
        </div>
      )}
      
      {/* Toggle UI Button */}
      <button
        onClick={() => setShowUI(!showUI)}
        style={{
          position: 'absolute',
          top: '20px',
          right: '20px',
          width: '50px',
          height: '50px',
          background: 'rgba(10, 20, 30, 0.85)',
          backdropFilter: 'blur(20px)',
          border: '1px solid rgba(107, 181, 199, 0.3)',
          borderRadius: '50%',
          color: '#f4e8d4',
          cursor: 'pointer',
          fontSize: '20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          transition: 'all 0.3s ease',
          boxShadow: '0 4px 15px rgba(0, 0, 0, 0.3)',
          zIndex: 1000
        }}
        onMouseEnter={(e) => {
          e.target.style.background = 'rgba(107, 181, 199, 0.2)';
          e.target.style.borderColor = '#6bb5c7';
        }}
        onMouseLeave={(e) => {
          e.target.style.background = 'rgba(10, 20, 30, 0.85)';
          e.target.style.borderColor = 'rgba(107, 181, 199, 0.3)';
        }}
      >
        {showUI ? '' : ''}
      </button>
      
      {/* Zoom Controls */}
      {isMobile && (
        <div style={{
          position: 'absolute',
          top: '80px',
          right: '20px',
          display: 'flex',
          flexDirection: 'column',
          gap: '10px',
          zIndex: 1000
        }}>
          <button
            onClick={() => zoomCentered(Math.min(canvasZoom + 0.25, 3))}
            disabled={canvasZoom >= 3}
            style={{
              width: '50px',
              height: '50px',
              background: 'rgba(10, 20, 30, 0.85)',
              backdropFilter: 'blur(20px)',
              border: '1px solid rgba(107, 181, 199, 0.3)',
              borderRadius: '50%',
              color: canvasZoom >= 3 ? '#666' : '#f4e8d4',
              cursor: canvasZoom >= 3 ? 'not-allowed' : 'pointer',
              fontSize: '24px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              boxShadow: '0 4px 15px rgba(0, 0, 0, 0.3)',
              opacity: canvasZoom >= 3 ? 0.5 : 1
            }}
          >
            +
          </button>
          <button
            onClick={() => zoomCentered(Math.max(canvasZoom - 0.25, 0.25))}
            disabled={canvasZoom <= 0.25}
            style={{
              width: '50px',
              height: '50px',
              background: 'rgba(10, 20, 30, 0.85)',
              backdropFilter: 'blur(20px)',
              border: '1px solid rgba(107, 181, 199, 0.3)',
              borderRadius: '50%',
              color: canvasZoom <= 0.25 ? '#666' : '#f4e8d4',
              cursor: canvasZoom <= 0.25 ? 'not-allowed' : 'pointer',
              fontSize: '24px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              boxShadow: '0 4px 15px rgba(0, 0, 0, 0.3)',
              opacity: canvasZoom <= 0.25 ? 0.5 : 1
            }}
          >
            
          </button>
          <div style={{
            background: 'rgba(10, 20, 30, 0.85)',
            backdropFilter: 'blur(20px)',
            border: '1px solid rgba(107, 181, 199, 0.3)',
            borderRadius: '20px',
            padding: '8px 12px',
            color: '#6bb5c7',
            fontSize: '12px',
            textAlign: 'center',
            fontWeight: '600'
          }}>
            {Math.round(canvasZoom * 100)}%
          </div>
          <button
            onClick={() => {
              setCanvasZoom(1);
              // On mobile, reset to centered position
              if (isMobile) {
                setCanvasPan({ x: -(window.innerWidth / 2), y: -(window.innerHeight / 2) });
              } else {
                setCanvasPan({ x: 0, y: 0 });
              }
            }}
            disabled={canvasZoom === 1 && canvasPan.x === 0 && canvasPan.y === 0}
            style={{
              width: '50px',
              height: '50px',
              background: 'rgba(10, 20, 30, 0.85)',
              backdropFilter: 'blur(20px)',
              border: '1px solid rgba(107, 181, 199, 0.3)',
              borderRadius: '50%',
              color: (canvasZoom === 1 && canvasPan.x === 0 && canvasPan.y === 0) ? '#666' : '#f4e8d4',
              cursor: (canvasZoom === 1 && canvasPan.x === 0 && canvasPan.y === 0) ? 'not-allowed' : 'pointer',
              fontSize: '18px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              boxShadow: '0 4px 15px rgba(0, 0, 0, 0.3)',
              opacity: (canvasZoom === 1 && canvasPan.x === 0 && canvasPan.y === 0) ? 0.5 : 1
            }}
            title="Reset view"
          >
            
          </button>
        </div>
      )}
      
      
      {/* Control Panel */}
      {showUI && (
      <div 
        className="control-panel"
        onClick={(e) => {
          // If collapsed and on mobile, clicking anywhere expands it
          if (panelCollapsed && isMobile && e.target.closest('.control-panel') && !e.target.closest('button')) {
            setPanelCollapsed(false);
          }
        }}
        style={{
        // Responsive positioning
        ...(isMobile ? {
          position: 'fixed',
          bottom: '0',
          left: '0',
          right: '0',
          width: '100%',
          borderRadius: '20px 20px 0 0',
          height: panelCollapsed ? '60px' : '70vh',
          maxHeight: '70vh',
          transition: 'height 0.3s ease',
          borderTop: '2px solid rgba(107, 181, 199, 0.5)',
          cursor: panelCollapsed ? 'pointer' : 'default',
          display: 'flex',
          flexDirection: 'column',
          paddingBottom: 'env(safe-area-inset-bottom)'
        } : {
          position: 'absolute',
          top: '30px',
          left: '30px',
          minWidth: panelCollapsed ? '60px' : '280px',
          maxWidth: panelCollapsed ? '60px' : 'none',
          maxHeight: panelCollapsed ? '60px' : 'calc(100vh - 60px)',
          transition: 'all 0.3s ease'
        }),
        background: 'rgba(10, 20, 30, 0.95)',
        backdropFilter: 'blur(20px)',
        border: '1px solid rgba(107, 181, 199, 0.3)',
        padding: panelCollapsed ? '15px' : '30px',
        overflowY: panelCollapsed ? 'hidden' : 'auto',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4), 0 0 60px rgba(107, 181, 199, 0.1)',
        userSelect: 'none',
        zIndex: 2000
      }}>
        {/* Collapse/Expand Button */}
        <button
          onClick={() => setPanelCollapsed(!panelCollapsed)}
          style={{
            position: 'absolute',
            top: isMobile ? '12px' : '15px',
            right: isMobile ? '15px' : '15px',
            background: 'rgba(107, 181, 199, 0.15)',
            border: '1px solid rgba(107, 181, 199, 0.4)',
            borderRadius: '8px',
            padding: isMobile ? '10px 14px' : '8px 12px',
            color: '#6bb5c7',
            cursor: 'pointer',
            fontSize: isMobile ? '18px' : '16px',
            transition: 'all 0.2s ease',
            zIndex: 10,
            fontWeight: '600'
          }}
          title={panelCollapsed ? 'Expand panel' : 'Collapse panel'}
        >
          {panelCollapsed ? (isMobile ? '' : '') : (isMobile ? '' : '')}
        </button>
        
        {!panelCollapsed && (
        <>
        <h1 style={{
          margin: '0 0 25px 0',
          fontSize: isMobile ? '18px' : '28px',
          fontWeight: '300',
          letterSpacing: '2px',
          color: '#f4e8d4',
          textTransform: 'uppercase',
          textAlign: 'center',
          textShadow: '0 0 20px rgba(107, 181, 199, 0.3)',
          paddingBottom: '10px',
          paddingRight: isMobile ? '60px' : '40px',
          borderBottom: '1px solid rgba(107, 181, 199, 0.2)',
          position: 'relative'
        }}>
          {!isMobile && (
          <div style={{ 
            fontSize: '10px', 
            opacity: 0.4, 
            letterSpacing: '4px',
            marginBottom: '5px'
          }}>
            
          </div>
          )}
          Geometric Painter
          
          {/* Close button - desktop only */}
          {!isMobile && (
          <button
            onClick={() => setShowUI(false)}
            style={{
              position: 'absolute',
              top: '0',
              right: '0',
              width: '30px',
              height: '30px',
              background: 'transparent',
              border: '1px solid rgba(107, 181, 199, 0.3)',
              borderRadius: '8px',
              color: '#6bb5c7',
              fontSize: '16px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              transition: 'all 0.3s ease',
              fontFamily: 'inherit'
            }}
            title="Hide panel (press H to toggle)"
          >
            
          </button>
          )}
        </h1>
        
        {/* Brush Mode */}
        <div style={{ marginBottom: '25px' }}>
          <label style={{
            display: 'block',
            marginBottom: '12px',
            color: '#e6a660',
            fontSize: '11px',
            letterSpacing: '1.5px',
            textTransform: 'uppercase',
            fontWeight: '600'
          }}>
            Brush Mode {shapeMode && '(Off)'}
          </label>
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
            {[
              { id: 'segments', label: 'Segments' },
              { id: 'dots', label: 'Dots' },
              { id: 'radials', label: 'Radials' },
              { id: 'crosshatch', label: 'Hatch' },
              { id: 'stipple', label: 'Stipple' },
              { id: 'fine', label: 'Fine Line' }
            ].map(mode => (
              <button
                key={mode.id}
                onClick={() => {
                  setBrushMode(mode.id);
                  setShapeMode(null);
                  setBlendMode(false);
                  setFillMode(false);
                }}
                style={{
                  padding: '10px',
                  background: brushMode === mode.id && !shapeMode && !blendMode && !fillMode
                    ? 'linear-gradient(135deg, #4a8a9e, #6bb5c7)'
                    : 'rgba(255, 255, 255, 0.05)',
                  border: brushMode === mode.id && !shapeMode && !blendMode && !fillMode
                    ? '1px solid #6bb5c7' 
                    : '1px solid rgba(255, 255, 255, 0.1)',
                  borderRadius: '8px',
                  color: brushMode === mode.id && !shapeMode && !blendMode && !fillMode ? '#0a0a0a' : '#f4e8d4',
                  cursor: 'pointer',
                  fontSize: '10px',
                  letterSpacing: '1px',
                  textTransform: 'uppercase',
                  fontWeight: brushMode === mode.id && !shapeMode && !blendMode && !fillMode ? '600' : '400',
                  transition: 'all 0.3s ease',
                  fontFamily: 'inherit'
                }}
              >
                {mode.label}
              </button>
            ))}
          </div>
        </div>
        
        {/* Blend Mode Toggle */}
        <div style={{ marginBottom: '25px' }}>
          <button
            onClick={() => {
              setBlendMode(!blendMode);
              setShapeMode(null);
              if (!blendMode) setFillMode(false);
            }}
            style={{
              width: '100%',
              padding: '12px',
              background: blendMode
                ? 'linear-gradient(135deg, #8a5a8a, #c45a4a)'
                : 'rgba(255, 255, 255, 0.05)',
              border: blendMode
                ? '1px solid #c45a4a' 
                : '1px solid rgba(255, 255, 255, 0.1)',
              borderRadius: '10px',
              color: blendMode ? '#0a0a0a' : '#f4e8d4',
              cursor: 'pointer',
              fontSize: '11px',
              letterSpacing: '1.5px',
              textTransform: 'uppercase',
              fontWeight: '600',
              transition: 'all 0.3s ease',
              fontFamily: 'inherit'
            }}
          >
            {blendMode ? ' Blend Mode Active' : 'Blend/Smudge Mode'}
          </button>
          {blendMode && (
            <p style={{
              margin: '10px 0 0 0',
              fontSize: '10px',
              color: '#c45a4a',
              lineHeight: '1.5',
              fontStyle: 'italic'
            }}>
              Drag to smudge and blend pixels underneath
            </p>
          )}
        </div>
        
        {/* Fill Mode Toggle */}
        <div style={{ marginBottom: '25px' }}>
          <button
            onClick={() => {
              setFillMode(!fillMode);
              setShapeMode(null);
              if (!fillMode) setBlendMode(false);
            }}
            style={{
              width: '100%',
              padding: '12px',
              background: fillMode
                ? 'linear-gradient(135deg, #e6a660, #d4854d)'
                : 'rgba(255, 255, 255, 0.05)',
              border: fillMode
                ? '1px solid #e6a660' 
                : '1px solid rgba(255, 255, 255, 0.1)',
              borderRadius: '10px',
              color: fillMode ? '#0a0a0a' : '#f4e8d4',
              cursor: 'pointer',
              fontSize: '11px',
              letterSpacing: '1.5px',
              textTransform: 'uppercase',
              fontWeight: '600',
              transition: 'all 0.3s ease',
              fontFamily: 'inherit'
            }}
          >
            {fillMode ? ' Fill Mode Active' : 'Fill Mode'}
          </button>
          {fillMode && (
            <>
              <p style={{
                margin: '10px 0',
                fontSize: '10px',
                color: '#e6a660',
                lineHeight: '1.5',
                fontStyle: 'italic'
              }}>
                Click to fill enclosed areas
              </p>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                {[
                  { id: 'solid', label: 'Solid' },
                  { id: 'dots', label: 'Dots' },
                  { id: 'lines', label: 'Lines' },
                  { id: 'crosshatch', label: 'Hatch' },
                  { id: 'stipple', label: 'Stipple' },
                  { id: 'mesh', label: 'Mesh' }
                ].map(pattern => (
                  <button
                    key={pattern.id}
                    onClick={() => setFillPattern(pattern.id)}
                    style={{
                      padding: '8px',
                      background: fillPattern === pattern.id
                        ? 'linear-gradient(135deg, #e6a660, #d4854d)'
                        : 'rgba(255, 255, 255, 0.05)',
                      border: fillPattern === pattern.id
                        ? '1px solid #e6a660' 
                        : '1px solid rgba(255, 255, 255, 0.1)',
                      borderRadius: '6px',
                      color: fillPattern === pattern.id ? '#0a0a0a' : '#f4e8d4',
                      cursor: 'pointer',
                      fontSize: '9px',
                      letterSpacing: '1px',
                      textTransform: 'uppercase',
                      fontWeight: fillPattern === pattern.id ? '600' : '400',
                      transition: 'all 0.3s ease',
                      fontFamily: 'inherit'
                    }}
                  >
                    {pattern.label}
                  </button>
                ))}
              </div>
              
              {/* Pattern Density Control */}
              {fillPattern !== 'solid' && (
                <div style={{ marginTop: '12px' }}>
                  <label style={{
                    display: 'block',
                    marginBottom: '8px',
                    color: '#6bb5c7',
                    fontSize: '9px',
                    letterSpacing: '1px',
                    textTransform: 'uppercase',
                    fontWeight: '500'
                  }}>
                    Pattern Density: {fillPatternDensity}
                  </label>
                  <input
                    type="range"
                    min="10"
                    max="100"
                    value={fillPatternDensity}
                    onChange={(e) => setFillPatternDensity(Number(e.target.value))}
                    style={{
                      width: '100%',
                      height: '4px',
                      borderRadius: '2px',
                      outline: 'none',
                      background: `linear-gradient(to right, #6bb5c7 0%, #6bb5c7 ${fillPatternDensity}%, rgba(255, 255, 255, 0.1) ${fillPatternDensity}%, rgba(255, 255, 255, 0.1) 100%)`,
                      WebkitAppearance: 'none',
                      appearance: 'none',
                      cursor: 'pointer'
                    }}
                  />
                </div>
              )}
              
              {/* Pattern Rotation Control */}
              {fillPattern !== 'solid' && (
                <div style={{ marginTop: '12px' }}>
                  <label style={{
                    display: 'block',
                    marginBottom: '8px',
                    color: '#6bb5c7',
                    fontSize: '9px',
                    letterSpacing: '1px',
                    textTransform: 'uppercase',
                    fontWeight: '500'
                  }}>
                    Pattern Rotation: {fillPatternRotation}
                  </label>
                  <input
                    type="range"
                    min="0"
                    max="360"
                    value={fillPatternRotation}
                    onChange={(e) => setFillPatternRotation(Number(e.target.value))}
                    style={{
                      width: '100%',
                      height: '4px',
                      borderRadius: '2px',
                      outline: 'none',
                      background: `linear-gradient(to right, #6bb5c7 0%, #6bb5c7 ${(fillPatternRotation / 360) * 100}%, rgba(255, 255, 255, 0.1) ${(fillPatternRotation / 360) * 100}%, rgba(255, 255, 255, 0.1) 100%)`,
                      WebkitAppearance: 'none',
                      appearance: 'none',
                      cursor: 'pointer'
                    }}
                  />
                </div>
              )}
            </>
          )}
        </div>
        
        {/* Bleed Mode Toggle */}
        <div style={{ marginBottom: '25px' }}>
          <button
            onClick={() => setBleedEnabled(!bleedEnabled)}
            style={{
              width: '100%',
              padding: '12px',
              background: bleedEnabled
                ? 'linear-gradient(135deg, #7acab5, #5a9a8a)'
                : 'rgba(255, 255, 255, 0.05)',
              border: bleedEnabled
                ? '1px solid #7acab5' 
                : '1px solid rgba(255, 255, 255, 0.1)',
              borderRadius: '10px',
              color: bleedEnabled ? '#0a0a0a' : '#f4e8d4',
              cursor: 'pointer',
              fontSize: '11px',
              letterSpacing: '1.5px',
              textTransform: 'uppercase',
              fontWeight: '600',
              transition: 'all 0.3s ease',
              fontFamily: 'inherit'
            }}
          >
            {bleedEnabled ? ' Bleed Mode Active' : 'Bleed/Extend Mode'}
          </button>
          {bleedEnabled && (
            <p style={{
              margin: '10px 0 0 0',
              fontSize: '10px',
              color: '#7acab5',
              lineHeight: '1.5',
              fontStyle: 'italic'
            }}>
              Hold still to radiate outward, or drag to trail extending patterns with your cursor
            </p>
          )}
        </div>
        
        {/* Symmetry Mode */}
        <div style={{ marginBottom: '25px' }}>
          <label style={{
            display: 'block',
            marginBottom: '12px',
            color: '#e6a660',
            fontSize: '11px',
            letterSpacing: '1.5px',
            textTransform: 'uppercase',
            fontWeight: '600'
          }}>
            Symmetry Mode
          </label>
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px', marginBottom: '10px' }}>
            {[
              { id: 'none', label: 'None' },
              { id: 'mirror', label: 'Mirror' }
            ].map(mode => (
              <button
                key={mode.id}
                onClick={() => setSymmetryMode(mode.id)}
                style={{
                  padding: '10px',
                  background: symmetryMode === mode.id
                    ? 'linear-gradient(135deg, #6bb5c7, #4a8a9e)'
                    : 'rgba(255, 255, 255, 0.05)',
                  border: symmetryMode === mode.id
                    ? '1px solid #6bb5c7' 
                    : '1px solid rgba(255, 255, 255, 0.1)',
                  borderRadius: '8px',
                  color: symmetryMode === mode.id ? '#0a0a0a' : '#f4e8d4',
                  cursor: 'pointer',
                  fontSize: '10px',
                  letterSpacing: '1px',
                  textTransform: 'uppercase',
                  fontWeight: symmetryMode === mode.id ? '600' : '400',
                  transition: 'all 0.3s ease',
                  fontFamily: 'inherit'
                }}
              >
                {mode.label}
              </button>
            ))}
          </div>
          {symmetryMode === 'mirror' && (
            <>
              <label style={{
                display: 'block',
                marginBottom: '8px',
                color: '#6bb5c7',
                fontSize: '10px',
                letterSpacing: '1px'
              }}>
                Mirror Axis: {mirrorAngle}
              </label>
              <input
                type="range"
                min="0"
                max="180"
                value={mirrorAngle}
                onChange={(e) => setMirrorAngle(Number(e.target.value))}
                style={{
                  width: '100%',
                  accentColor: '#6bb5c7'
                }}
              />
              <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                marginTop: '5px',
                fontSize: '9px',
                color: '#6bb5c7',
                opacity: 0.6
              }}>
                <span>0 (horizontal)</span>
                <span>90 (vertical)</span>
                <span>180</span>
              </div>
            </>
          )}
        </div>
        
        {/* Shape Stamps */}
        <div style={{ marginBottom: '25px' }}>
          <label style={{
            display: 'block',
            marginBottom: '12px',
            color: '#e6a660',
            fontSize: '11px',
            letterSpacing: '1.5px',
            textTransform: 'uppercase',
            fontWeight: '600'
          }}>
            Shape Stamps
          </label>
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
            {[
              { id: 'concentric', label: 'Rings' },
              { id: 'radial', label: 'Radiant' },
              { id: 'mesh', label: 'Mesh' },
              { id: 'dotted', label: 'Dotted' },
              { id: 'circle', label: 'Circle' },
              { id: 'mandala', label: 'Mandala' }
            ].map(shape => (
              <button
                key={shape.id}
                onClick={() => {
                  setShapeMode(shape.id);
                  setBlendMode(false);
                  setFillMode(false);
                }}
                style={{
                  padding: '10px',
                  background: shapeMode === shape.id
                    ? 'linear-gradient(135deg, #e6a660, #d4854d)'
                    : 'rgba(255, 255, 255, 0.05)',
                  border: shapeMode === shape.id
                    ? '1px solid #e6a660' 
                    : '1px solid rgba(255, 255, 255, 0.1)',
                  borderRadius: '8px',
                  color: shapeMode === shape.id ? '#0a0a0a' : '#f4e8d4',
                  cursor: 'pointer',
                  fontSize: '10px',
                  letterSpacing: '1px',
                  textTransform: 'uppercase',
                  fontWeight: shapeMode === shape.id ? '600' : '400',
                  transition: 'all 0.3s ease',
                  fontFamily: 'inherit'
                }}
              >
                {shape.label}
              </button>
            ))}
          </div>
          
          {/* Shape Fill Toggle */}
          <div style={{ marginTop: '12px', display: 'flex', gap: '8px' }}>
            <button
              onClick={() => setShapeFilled(false)}
              style={{
                flex: 1,
                padding: '8px',
                background: !shapeFilled
                  ? 'linear-gradient(135deg, #6bb5c7, #4a8a9e)'
                  : 'rgba(255, 255, 255, 0.05)',
                border: !shapeFilled
                  ? '1px solid #6bb5c7' 
                  : '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                color: !shapeFilled ? '#0a0a0a' : '#f4e8d4',
                cursor: 'pointer',
                fontSize: '9px',
                letterSpacing: '1px',
                textTransform: 'uppercase',
                fontWeight: !shapeFilled ? '600' : '400',
                transition: 'all 0.3s ease',
                fontFamily: 'inherit'
              }}
            >
              Outline
            </button>
            <button
              onClick={() => setShapeFilled(true)}
              style={{
                flex: 1,
                padding: '8px',
                background: shapeFilled
                  ? 'linear-gradient(135deg, #6bb5c7, #4a8a9e)'
                  : 'rgba(255, 255, 255, 0.05)',
                border: shapeFilled
                  ? '1px solid #6bb5c7' 
                  : '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                color: shapeFilled ? '#0a0a0a' : '#f4e8d4',
                cursor: 'pointer',
                fontSize: '9px',
                letterSpacing: '1px',
                textTransform: 'uppercase',
                fontWeight: shapeFilled ? '600' : '400',
                transition: 'all 0.3s ease',
                fontFamily: 'inherit'
              }}
            >
              Filled
            </button>
          </div>
        </div>
        
        {/* Size Control */}
        <div style={{ marginBottom: '25px' }}>
          <label style={{
            display: 'block',
            marginBottom: '12px',
            color: '#e6a660',
            fontSize: '11px',
            letterSpacing: '1.5px',
            textTransform: 'uppercase',
            fontWeight: '600'
          }}>
            Size: {brushSize}
          </label>
          <input
            type="range"
            min="10"
            max="120"
            value={brushSize}
            onChange={(e) => setBrushSize(Number(e.target.value))}
            style={{
              width: '100%',
              accentColor: '#6bb5c7'
            }}
          />
        </div>
        
        {/* Line Weight Control */}
        <div style={{ marginBottom: '25px' }}>
          <label style={{
            display: 'block',
            marginBottom: '12px',
            color: '#e6a660',
            fontSize: '11px',
            letterSpacing: '1.5px',
            textTransform: 'uppercase',
            fontWeight: '600'
          }}>
            Line Weight: {lineWeight.toFixed(1)}
          </label>
          <input
            type="range"
            min="0.5"
            max="5"
            step="0.5"
            value={lineWeight}
            onChange={(e) => setLineWeight(Number(e.target.value))}
            style={{
              width: '100%',
              accentColor: '#6bb5c7'
            }}
          />
        </div>
        
        {/* Opacity Control */}
        <div style={{ marginBottom: '25px' }}>
          <label style={{
            display: 'block',
            marginBottom: '12px',
            color: '#e6a660',
            fontSize: '11px',
            letterSpacing: '1.5px',
            textTransform: 'uppercase',
            fontWeight: '600'
          }}>
            Opacity: {Math.round(opacity * 100)}%
          </label>
          <input
            type="range"
            min="0.1"
            max="1"
            step="0.1"
            value={opacity}
            onChange={(e) => setOpacity(Number(e.target.value))}
            style={{
              width: '100%',
              accentColor: '#6bb5c7'
            }}
          />
        </div>
        
        {/* Color Palette */}
        <div style={{ marginBottom: '25px' }}>
          <label style={{
            display: 'block',
            marginBottom: '12px',
            color: '#e6a660',
            fontSize: '11px',
            letterSpacing: '1.5px',
            textTransform: 'uppercase',
            fontWeight: '600'
          }}>
            Color Palette
          </label>
          
          {/* Palette Selector */}
          <div style={{ marginBottom: '12px' }}>
            <select
              value={currentPalette}
              onChange={(e) => setCurrentPalette(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
                borderRadius: '8px',
                color: '#f4e8d4',
                fontSize: '10px',
                letterSpacing: '1px',
                textTransform: 'uppercase',
                fontWeight: '500',
                cursor: 'pointer',
                fontFamily: 'inherit',
                outline: 'none'
              }}
            >
              {Object.entries(colorPalettes).map(([key, palette]) => (
                <option key={key} value={key} style={{ background: '#1a1a1a', color: '#f4e8d4' }}>
                  {palette.name}
                </option>
              ))}
            </select>
          </div>
          
          {/* Image Upload for Color Extraction */}
          <div style={{ marginBottom: '12px' }}>
            <input
              type="file"
              accept="image/*"
              onChange={handleImageUpload}
              style={{ display: 'none' }}
              id="imageUpload"
            />
            <label
              htmlFor="imageUpload"
              style={{
                display: 'block',
                width: '100%',
                padding: '10px',
                background: 'linear-gradient(135deg, #6bb5c7, #4a8a9e)',
                border: '1px solid #6bb5c7',
                borderRadius: '8px',
                color: '#0a0a0a',
                fontSize: '9px',
                letterSpacing: '1px',
                textTransform: 'uppercase',
                fontWeight: '600',
                textAlign: 'center',
                cursor: 'pointer',
                transition: 'all 0.3s ease',
                fontFamily: 'inherit'
              }}
            >
               Upload Image for Colors
            </label>
          </div>
          
          <div style={{
            display: 'grid',
            gridTemplateColumns: 'repeat(4, 1fr)',
            gap: '8px'
          }}>
            {colorPalette.map((c) => (
              <button
                key={c.color}
                onClick={() => setSelectedColor(c.color)}
                title={c.name}
                style={{
                  width: '100%',
                  aspectRatio: '1',
                  background: c.color,
                  border: selectedColor === c.color 
                    ? '3px solid #f4e8d4' 
                    : '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  transition: 'all 0.3s ease',
                  boxShadow: selectedColor === c.color 
                    ? `0 0 20px ${c.color}80` 
                    : 'none',
                  transform: selectedColor === c.color ? 'scale(1.1)' : 'scale(1)'
                }}
              />
            ))}
          </div>
        </div>
        
        {/* Action Buttons */}
        <div style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>
          <div style={{ display: 'flex', gap: '10px' }}>
            <button
              onClick={clearCanvas}
              style={{
                flex: 1,
                padding: '14px',
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
                borderRadius: '10px',
                color: '#f4e8d4',
                cursor: 'pointer',
                fontSize: '11px',
                letterSpacing: '1.5px',
                textTransform: 'uppercase',
                fontWeight: '600',
                transition: 'all 0.3s ease',
                fontFamily: 'inherit'
              }}
              onMouseEnter={(e) => {
                e.target.style.background = 'rgba(255, 255, 255, 0.1)';
                e.target.style.borderColor = '#e87a6a';
              }}
              onMouseLeave={(e) => {
                e.target.style.background = 'rgba(255, 255, 255, 0.05)';
                e.target.style.borderColor = 'rgba(255, 255, 255, 0.2)';
              }}
            >
              Clear
            </button>
            <button
              onClick={saveImage}
              style={{
                flex: 1,
                padding: '14px',
                background: 'linear-gradient(135deg, #e6a660, #d4854d)',
                border: '1px solid #e6a660',
                borderRadius: '10px',
                color: '#0a0a0a',
                cursor: 'pointer',
                fontSize: '11px',
                letterSpacing: '1.5px',
                textTransform: 'uppercase',
                fontWeight: '600',
                transition: 'all 0.3s ease',
                fontFamily: 'inherit',
                boxShadow: '0 4px 15px rgba(230, 166, 96, 0.3)'
              }}
              onMouseEnter={(e) => {
                e.target.style.transform = 'translateY(-2px)';
                e.target.style.boxShadow = '0 6px 20px rgba(230, 166, 96, 0.4)';
              }}
              onMouseLeave={(e) => {
                e.target.style.transform = 'translateY(0)';
                e.target.style.boxShadow = '0 4px 15px rgba(230, 166, 96, 0.3)';
              }}
            >
              PNG
            </button>
            <button
              onClick={saveAsJPEG}
              style={{
                flex: 1,
                padding: '14px',
                background: 'linear-gradient(135deg, #7acab5, #5a9a8a)',
                border: '1px solid #7acab5',
                borderRadius: '10px',
                color: '#0a0a0a',
                cursor: 'pointer',
                fontSize: '11px',
                letterSpacing: '1.5px',
                textTransform: 'uppercase',
                fontWeight: '600',
                transition: 'all 0.3s ease',
                fontFamily: 'inherit',
                boxShadow: '0 4px 15px rgba(122, 202, 181, 0.3)'
              }}
              onMouseEnter={(e) => {
                e.target.style.transform = 'translateY(-2px)';
                e.target.style.boxShadow = '0 6px 20px rgba(122, 202, 181, 0.4)';
              }}
              onMouseLeave={(e) => {
                e.target.style.transform = 'translateY(0)';
                e.target.style.boxShadow = '0 4px 15px rgba(122, 202, 181, 0.3)';
              }}
            >
              JPEG
            </button>
          </div>
          <button
            onClick={undo}
            disabled={!canUndo}
            style={{
              width: '100%',
              padding: '14px',
              background: !canUndo
                ? 'rgba(255, 255, 255, 0.02)'
                : 'rgba(107, 181, 199, 0.15)',
              border: '1px solid rgba(107, 181, 199, 0.3)',
              borderRadius: '10px',
              color: !canUndo ? '#4a4a4a' : '#6bb5c7',
              cursor: !canUndo ? 'not-allowed' : 'pointer',
              fontSize: '11px',
              letterSpacing: '1.5px',
              textTransform: 'uppercase',
              fontWeight: '600',
              transition: 'all 0.3s ease',
              fontFamily: 'inherit',
              opacity: !canUndo ? 0.3 : 1
            }}
          >
             Undo (Ctrl+Z)
          </button>
        </div>
        </>
        )}
        {panelCollapsed && (
          <div style={{
            color: '#f4e8d4',
            fontSize: isMobile ? '20px' : '16px',
            textAlign: 'center',
            fontWeight: '600',
            letterSpacing: '2px',
            padding: isMobile ? '10px' : '5px',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '5px'
          }}>
            <div style={{ fontSize: isMobile ? '28px' : '20px' }}>
              {isMobile ? '' : ''}
            </div>
            {isMobile && (
              <div style={{ 
                fontSize: '10px', 
                opacity: 0.7,
                letterSpacing: '2px',
                textTransform: 'uppercase',
                marginTop: '5px'
              }}>
                Tap to Open  2 Fingers to Pan
              </div>
            )}
          </div>
        )}
      </div>
      )}
      
      {/* Panning Indicator */}
      {isPanning && (
        <div style={{
          position: 'fixed',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          background: 'rgba(107, 181, 199, 0.9)',
          color: '#0a0a0a',
          padding: '15px 25px',
          borderRadius: '15px',
          fontSize: '14px',
          fontWeight: '600',
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.4)',
          zIndex: 10000,
          pointerEvents: 'none',
          letterSpacing: '1px'
        }}>
           PANNING 
        </div>
      )}
      
      {/* Panel Toggle Button - Shows when panel is hidden */}
      {!showUI && (
        <button
          onClick={() => setShowUI(true)}
          style={{
            position: 'absolute',
            top: '30px',
            left: '30px',
            width: '50px',
            height: '50px',
            background: 'rgba(10, 20, 30, 0.85)',
            backdropFilter: 'blur(20px)',
            border: '2px solid rgba(107, 181, 199, 0.5)',
            borderRadius: '50%',
            color: '#6bb5c7',
            fontSize: '24px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            boxShadow: '0 4px 20px rgba(0, 0, 0, 0.4)',
            transition: 'all 0.3s ease',
            zIndex: 100,
            fontFamily: 'inherit'
          }}
          onMouseEnter={(e) => {
            e.currentTarget.style.transform = 'scale(1.1)';
            e.currentTarget.style.background = 'rgba(107, 181, 199, 0.2)';
          }}
          onMouseLeave={(e) => {
            e.currentTarget.style.transform = 'scale(1)';
            e.currentTarget.style.background = 'rgba(10, 20, 30, 0.85)';
          }}
        >
          
        </button>
      )}
      
      {/* Instructions */}
      {showUI && (
      <div 
        onClick={() => setShowInstructions(!showInstructions)}
        style={{
        position: 'absolute',
        bottom: '30px',
        right: '30px',
        background: 'rgba(10, 20, 30, 0.7)',
        backdropFilter: 'blur(20px)',
        border: '1px solid rgba(107, 181, 199, 0.2)',
        borderRadius: '15px',
        padding: '20px 25px',
        maxWidth: '320px',
        color: '#f4e8d4',
        fontSize: '13px',
        lineHeight: '1.8',
        fontWeight: '300',
        letterSpacing: '0.5px',
        cursor: 'pointer',
        transition: 'all 0.3s ease',
        userSelect: 'none'
      }}
      onMouseEnter={(e) => {
        e.currentTarget.style.background = 'rgba(10, 20, 30, 0.85)';
        e.currentTarget.style.borderColor = 'rgba(107, 181, 199, 0.4)';
      }}
      onMouseLeave={(e) => {
        e.currentTarget.style.background = 'rgba(10, 20, 30, 0.7)';
        e.currentTarget.style.borderColor = 'rgba(107, 181, 199, 0.2)';
      }}
      >
        <p style={{ margin: '0 0 10px 0', color: '#e6a660', fontWeight: '600', fontSize: '11px', letterSpacing: '1.5px', textTransform: 'uppercase', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <span>How to Use</span>
          <span style={{ fontSize: '14px', opacity: 0.6 }}>{showInstructions ? '' : ''}</span>
        </p>
        {!showInstructions && (
          <p style={{ margin: 0, fontSize: '11px', opacity: 0.6, fontStyle: 'italic' }}>
            Click to expand
          </p>
        )}
        {showInstructions && (
        <>
        <p style={{ margin: '0 0 10px 0', fontSize: '11px', opacity: 0.7, fontStyle: 'italic', color: '#7acab5' }}>
           Press H to toggle panel  Click here to collapse  Works with mouse or touch
        </p>
        <p style={{ margin: '0 0 10px 0' }}>
          <strong style={{ color: '#6bb5c7' }}>Symmetry:</strong> Enable Mirror mode with adjustable axis angle (0-180) to create perfectly symmetrical compositions at any orientation.
        </p>
        <p style={{ margin: '0 0 10px 0' }}>
          <strong style={{ color: '#6bb5c7' }}>Brush Modes:</strong> Drag to draw segmented lines, dots, radial bursts, crosshatching, stippling, or fine lines.
        </p>
        <p style={{ margin: '0 0 10px 0' }}>
          <strong style={{ color: '#e6a660' }}>Shape Stamps:</strong> Click once to place geometric patterns - concentric rings, radiant bursts, mesh circles, spirals, and mandalas.
        </p>
        <p style={{ margin: '0 0 10px 0' }}>
          <strong style={{ color: '#7acab5' }}>Bleed Mode:</strong> Hold still to radiate patterns outward from one spot, or drag to trail extending patterns that follow your cursor.
        </p>
        <p style={{ margin: '0 0 10px 0' }}>
          <strong style={{ color: '#c45a4a' }}>Blend Mode:</strong> Drag to smudge and blend colors underneath, creating fluid transitions.
        </p>
        <p style={{ margin: 0 }}>
          <strong style={{ color: '#e6a660' }}>Fill Mode:</strong> Click to fill enclosed shapes with solid color or patterns (dots, lines, crosshatch, stipple).
        </p>
        </>
        )}
      </div>
      )}
    </div>
  );
};

// Component ready for use

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GeometricPainter />);
    </script>
</body>
</html>
